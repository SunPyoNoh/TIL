# 19/05/31

Databease : 2가지 유형(Business or User, Meta Data)의 데이터가 저장.

DBMS

계층형 - 망형 - 관계형 - 객체관계형 - 클러스터로 구성

Table - Column(속성) + Row(Record)

Primary Key - Not NULL +Unique

Foreign Key - 참조관계 (parent 테이블의 PK를 참조하는 child 테이블의 외래키)

null - 아직 값이 할당되지 않음을 의미, 0이 아니며 " " (공백)과도 다르다.

​	 	 산술연산 결과는 null, 비교연산(=, !=, >) 결과는 null, 논리연산 결과도 null.

​		  nvl(컬럼, null일때 리턴할 값) 함수를 사용해서 변환 후 처리해야한다.





SQL - 선언적 언어, 결과 기술

DML - select~, update~, insert~, delete~

DDL - create~, alter~, drop~, truncate, rename, comment~ 

DCL - grant~, revoke~

TCL - comiit, rollback, savepoint



검색 구문

select  *| [distinct] column, ... | expression [as] Alias

from 테이블명

[where 조건]

...

[order by 정렬기준컬럼 asc|desc]



테이블 구조 확인 -= desc, desibe

컬럼타입 :

char(size)

varxhr2 (size)l

number(p,s)

date

timetamp

timetamp with timezone

interval year to month

interval day to second

rowid



컴럼타이에 따른 연산 :

number - 산술연산

char/varchhr2 - ||결합연산자

dta e =±n, 1/24, date-datte



where절 연산자 :

in - 여러 값의 리스트에서 값들을 =, or

like - 문자 패턴비교, _,  % 만능문자와 함께 사용합니다.

between ~ and ~ - 범위 연산자, 하한값, 상한값을 포함해서 범위 비교

in null, is not null - null 비교

=,>,<=,!=, <>

조건이 여러개 이면 논리 연산자(not, and, or)로 결합합니다.

order by 컬럼;

order by 표현식;

order by 별칭;

order by column position;



함수 - 반드시 하나의 값을 리턴한다.

단일행함수 - characer, number, date, conversion

복수행함수

분석 (window) 함수



---



### 기타 단일행 함수(null처리, 조건 처리)



nvl(column, expression) : column 과 expression이 동일한 타입이어야 한다.

nvl2(column, expression1, expression2) : expression1 과 expression2 동일

coalesce(column, expression1, expression2, ...) : 함수의 파라미터값에서 null이 아닌 최초의 값을 리턴하고 함수는 종료한다.



nullif(expression1, expression2, ...) :  expression1과 expression2 동일한 타입이어야한다.

expression1, expression2의 값이 동일하면 null을 리턴하고, 값이 다르면 expression1 을 리턴한다.



문> 사원들중 커미션을 받지 않는 사원들은 -1으로 출력합니다.

```sql
select ename, sal, comm,nvl(comm,-1)
from emp;
```

문>사원들중 커미션을 받는 사원은 급여+커미션을 출력하고, 커미션을 받지 않는 사원은 'No Commission'으로 출력합니다. (이름, 급여, 커미션, 비고)

```sql
select ename, sal, comm, nvl(to_char(sal+comm),'No commit') "비고"
from emp;

select ename, sal, comm, nvl2(comm,to_char(sal+comm),'No commit') "비고"
from emp;
```



조건처리 함수 : decode함수(column, 표현식1, 리턴값1, 표현식2, 리턴값2, ...)

조건처리 표현식, 표준 sql3 : case [표현식] when [값|조건표현식]  then 값 [else 값] end



```sql
문> 사원들의 부서번호가 10이면 월급을 5%인상 부서번호가 20번이면 월급을 10%인상 그 외의 부서는 월금 100인상합니다.현재의 월급과 인상된 월급을 출력.

select ename, deptno, sla,
decode(deptno, 10, sal*1.05, 20, sal*1.1, 30, sal*1.03 , sal 100) "Increase"
from emp;

select ename, deptno, sal,
case deptno when 10 then sal*1.05
when 20 then sal*1.1
when 30 then sal*1.03 
else sal+100 end "Increase"
from emp;
    
```



```sql
문> 월급에 대한 세금 출력하시오
    월급이 1000미만이면 0,  
    2000미만이면 월급의 5%, 
    3000미만이면 월급의10%
    4000미만이면 월급의15%, 
    4000이상이면 월급의 20%

select ename, sal,
case when sal <1000 then 0
when sal>=1000 and sal<2000 then sal*0.05
when sal>=2000 and sal<3000 then sal*0.10
when sal>=3000 and sal<4000 then sal*0.15
when sal>=4000 then sal*0.2 end "TAX"
from emp;

select ename, sal, decode(trunc(sal/1000), 0 ,0
,1,sal*0.05
,2,sal*0.10
,3,sal*0.15
,sal*0.2) "TAX"
from emp;
```



---

### 그룹함수

그룹핑된 행 집합, 테이블의 전체 행 집합의 컬럼이 함수의 인수로 전달되고, 그결과는 반드시 1개 리턴

sum(number 타입 | expression )

avg(number 타입 | expression)

min(number, char, date 타입 | expression)

max(number, char, date 타입 | expression)

count([distinct]number, char, date 타입 | expression): null이 아닌 값의

stddev(number 타입 | expression) : 표준편차

variance(number 타입 | expression) : 분산



```sql

conn scott/oracle
문> 전체 사원의 급여 합계, 평균, 최대값, 최소값 결과 출력
select sum(sal), avg(sal), max(sal), min(sal) 
from emp;


문> 전체 emp테이블의 행수는?
select count(*) , count(empno)  --PK컬럼을 인수로 사용해도 됨
from emp;


문> 전체 사원들중에 가장 빠른 입사 날짜와 가장 최근의 입사 날짜는?
select min(hiredate), max(hiredate)
from emp;

문> 전체 사원들중에 이름순서가 가장 빠른 사원의 이름과 이름순서가 가장 늦은 사원의 이름은?
select min(ename), max(ename)
from emp; 

문> 사원들이 소속된 부서의 종류의 수 출력?
select count(distinct deptno)
from emp;

문> 커미션을 받는 사원수는?
select count(comm)       --null은 count하지 않습니다.
from emp;

※모든 그룹함수는 null을 함수 연산에 포함하지 않습니다, 반드시 null처리 후 그룹함수 적용해야 합니다

문> 전체 사원들의 커미션의 평균은?
select sum(comm)/count(*) , avg(comm)
from emp;

select sum(comm)/count(*) , avg(nvl(comm, 0))
from emp;
```



문> 부서번호와 부서의 평균 급여를 함께 출력

```sql
select deptno, avg(sal)
from emp;  --error

--그룹함수를 적용한 컬럼과 그룹함수를 적용하지 않은 컬럼이 select절에 함께 선언될 경우 반드시 그룹함수를 적용하지 않은 컬럼은 group by절에 선언해야한다.

select depno, avg(sal)
from emp
group by deptno;

--group by절에 선언한 컬럼이 select절에 선언은 선택적이다.
select avg(sal)
from emp
group by deptno;
-- group by 절에는 column명만 선언할 수 있다.
```



문> 부서와 직무별 급여 평균 출력

```sql
select deptno, job, avg(sal)
from emp
group by deptno, job;
```

문> 각 부터별로 인원수, 급여의 평균, 최저 급여, 최고 급여, 급여의 합을 구하여  급여의 합이 많은 순으로 출력.

```sql
select deptno, avg(sal), min(sal),max(sal),sum(sal)  ---세번째
from emp   ----첫번째
group by deptno    ----두번째
order by sum(sal) desc; --- order by 6 desc
```

문> EMP 테이블에서 부서 인원이 4명보다 많은 부서의 부서번호, 인원수, 
급여의 합을 출력하여라

```sql
select deptno, count(deptno), sum(sal)
from emp
group by deptno
having count(*)>4;
```

※ 그룹함수의 조건은 having 절에 선언. having절은 group by 절과 함께 사용한다.



문> EMP 테이블에서 급여가 부서별 최대 급여가 2900 이상인 부서에 대해서 
부서번호, 평균 급여, 급여의 합을 구하여 출력하여라.

```sql
select deptno, avg(sal), sum(sal) 
from emp
group by deptno
having max(sal)>=2900;
```



문> EMP 테이블에서 업무별 급여의 평균이 3000 이상인 업무에 대해서 업무면, 평균 급여, 급여의 합을 구하여 출력하여라.

```sql
select job, avg(sal), sum(sal) 
from emp
group by job
having avg(sal)>=3000;
```





employees, emp - 사원정보

departments, dept - 부서 정보

ex) 사원이름, 부서번호, 부서이름



oracle join syntax - where 절에 조인조건 선언 -> 누락됨

sql 1999 표준 syntax - from 절에 조인조건 선언



equi join (inner join)

non-equi join

self-join (자기참조 가능한 테이블에서만)

※ 조인 조건을 잘못 정의하거나, 조인 조건을 누락하면 cartesian product (cross join)

outer join(조인컬럼값이 null인 경우 결과집합에 포함시키기 위한 조인)



```sql
conn hr/oracle
문> 사원이름, 부서번호, 부서이름
select last_name, department_ik, department_name
from employees, departments; -- error

select a.last_name, a.department_ik, b.department_name
from employees a, departments b; --? 20명의 사원 데이터 (20*8)rows, cartesian product, 조인조건 누락

--natual join 은 oracle 서버가 조인할 테이블에서 동일한 이름의 컬럼으로 자동 equi 방식 조인을 수행합니다.
--natual join 은 조인할 테이블에서 동일한 이름의 컬럼 앞에 소유자 테이블명 또는 alias를 선언하지 않습니다.
--natual join 은 동일한 속성이지만, 설계할때 부모와 자식 테이블에서 이름을 다르게 정의하면 조인 수행 안됩니다
select a.last_name, a.department_id, b.department_name
from  employees a natural join  departments b;  -->?


select a.last_name, a.department_id, b.department_name
from  employees a join  departments b;  -->?

select a.last_name, a.department_id, b.department_name
from  employees a, departments b
where a.department_id = b.department_id
and a.manager_id = b.manager_id;


select a.last_name,  department_id, b.department_name
from  employees a  join  departments b using (department_id); 
```



```sql
create table copy_emp
as select empno, empid, ename, job, hiredate, sal, mgr, deptno deptid
from emp;

desc copy_emp
select * from copy_emp;

select a.empno, a.ename, b.deptno, b.dname
from emp a  inner join  dept b  on a.deptno = b.deptno;
```



```sql
문> 사원이름, 급여, 급여의 등급을 조회 출력 --non-equi join으로 해결

select a.ename,a.sal, b.grade
from emp a, salgrade b
where a.sal between b.losal and b.hisal;

select a.ename,a.sal, b.grade
from emp a join salgrade b on a.sal between b.losal and b.hisal;
```



문> 사원번호 사원이름 관리자번호 관리자이름을 조회결과 출력 --self join

```sql
select a.empno, a.ename, a.mgr, b.ename
from emp a, emp b
where a.mgr = b.empno;

select a.empno, a.ename, a.mgr, b.ename
from emp a join emp b on a.mgr = b.empno;
```



conn hr2/oracle	

desc employess

desc departments

desc locations

※ n개의 테이블을 조인할때 최소 조인 조건은 n-1개

문> 사원이름, 소속 부서이름, 부서가 위치한 도시를 조회 출력

```sql
select a.last_name , b.department_name, c.city
from employees a join departments b on a.department_id = b.department_id
join locations c on b.location_id = c.location_id;

select a.last_name, b.department_name, c.city
from employees a, departments b, locations c
where a.department_id = b.department_id and b.location_id = c.location_id;
```



문> 부서번호가 없는 사원을 포함해서 사원들의 부서이름를 함께 출력

```sql

insert into emp( empno, ename) values(8000,'Hong');
commit;

select a.empno, a.ename, a.deptno, b. dname
from emp a, dept b
where a.deptno = b.deptno; --8000번 hong사원 누락됨

select a.empno, a.ename, a.deptno, b. dname
from emp a, dept b
where a.deptno = b.deptno(+); --8000번 hong사원 포함
```



문> 부서정보를 기준으로 부서의 소속 사원을 출력하고,
소속 사원이 없는 부서도 출력합니다.

```sql
select b.deptno, b.dname, a.empno, a. ename
from emp a, dept b
where a.deptno = b.deptno
order by b.deptno; --40번 부서정보 누락

select b.deptno, b.dname, a.empno, a. ename
from emp a, dept b
where a.deptno(+) = b.deptno
order by b.deptno; --40번 부서정보 포함
```

